#!/usr/bin/python
#
# PLCAPI interactive shell
#
# Mark Huang <mlhuang@cs.princeton.edu>
# Copyright (C) 2005 The Trustees of Princeton University
#
# $Id: plcsh,v 1.3 2006/01/09 19:57:24 mlhuang Exp $
#

import os, sys
import plcapilib

# Parse additional options
shortopts = "c:"
longopts = ["command="]
moreusage = """
usage: %s [OPTION]...

Shell options:
        -c command      Single command to execute
""" % sys.argv[0]

command = None
(plcapi, moreopts, argv) = plcapilib.plcapi(globals(), sys.argv, shortopts, longopts, moreusage)
for opt, optval in moreopts.iteritems():
    if opt == "-c" or opt == "--command":
        command = optval

if command is not None:
    code = compile(command, "<stdin>", "single")
    exec code
    sys.exit(0)

print "PlanetLab Central API server at %s" % plcapi.server_url
if plcapi.auth['AuthMethod'] == "anonymous":
    prompt = "[anonymous]"
    print "Connected anonymously"
else:
    prompt = "[%s %s]" % (plcapi.auth['Username'], plcapi.auth['Role'])
    print "%s connected as %s using %s authentication" % \
          (plcapi.auth['Username'], plcapi.auth['Role'], plcapi.auth['AuthMethod'])
print 'Type "system.listMethods()" or "help(method)" for more information.'

# Readline and tab completion support
import atexit
import readline
import rlcompleter

# Load command history
history_path = os.path.join(os.environ["HOME"], ".plcapi_history")
try:
    file(history_path, 'a').close()
    readline.read_history_file(history_path)
    atexit.register(readline.write_history_file, history_path)
except IOError:
    pass

# Enable tab completion
readline.parse_and_bind("tab: complete")

try:
    while True:
        command = ""
        while True:
            # Get line
            try:
                if command == "":
                    sep = ">>> "
                else:
                    sep = "... "
                line = raw_input(prompt + sep)
            # Ctrl-C
            except KeyboardInterrupt:
                command = ""
                print
                break

            # Build up multi-line command
            command += line

            # Blank line or first line does not end in :
            if line == "" or (command == line and line[-1] != ':'):
                break

            command += os.linesep

        # Blank line
        if command == "":
            continue
        # Quit
        elif command in ["q", "quit", "exit"]:
            break

        try:
            # Do it
            code = compile(command, "<stdin>", "single")
            exec code
        except Exception, err:
            print err

except EOFError:
    print
    pass
